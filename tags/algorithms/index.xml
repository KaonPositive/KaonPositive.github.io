<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Jared Rosario</title>
    <link>https://kaonpositive.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on Jared Rosario</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 02 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://kaonpositive.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sorting Algorithms</title>
      <link>https://kaonpositive.github.io/posts/sortingalgos/</link>
      <pubDate>Sat, 02 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/sortingalgos/</guid>
      <description>Important terms:
 Comparison-based Sorting: Sort elements by comparing them with each other. Non-comparison-based Sorting: Sorts do NOT compare elements with one another.  Selection Sort Is a comparison-based sorting algorithm.
You basically iterate through the array and find the smallest/largest element. If the smallest/largest element is found, exchange it with the first element. Keep doing this until you reach at the end of list.
TLDR; Find smallest element and exchange it with element in the first position; find the second smallest element and exchange it in the second position, etc.</description>
    </item>
    
    <item>
      <title>CS477 Final Study Guide</title>
      <link>https://kaonpositive.github.io/posts/cs477finalreview/</link>
      <pubDate>Mon, 27 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs477finalreview/</guid>
      <description>Time Complexity Implementing Sparse Array w/ Search Structure In terms of implementing a sparse array with a search structure, you can implement any search strcuture as you wish (a search structure must be able have a find function which returns a boolean value. That will indicate whether the item is found or not).
For example, you can implement a sparse array with memos. With these memos, you have pairs (i, A[i]) where i is the query and A[i] is the collection of items/data of said query.</description>
    </item>
    
    <item>
      <title>CS477 Exam 3 Review</title>
      <link>https://kaonpositive.github.io/posts/cs477exam3review/</link>
      <pubDate>Mon, 20 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs477exam3review/</guid>
      <description>Kruskal&amp;rsquo;s Algorithm It is a greedy algorithm that gives an optimal solution for a minimum spanning tree for a connected weighted graph.
Steps to solve Kruskal&amp;rsquo;s Algorithm:
 Sort graph edges in nondecreasing order (from least to greatest). Then, starting with an empty subgraph, it scans the sorted list which adds the next edge on the list to the current subgraph IF it does NOT create a cycle. If the edge does create a cycle, simply just skip it.</description>
    </item>
    
    <item>
      <title>CS 477 Study Guide</title>
      <link>https://kaonpositive.github.io/posts/cs477notes01/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs477notes01/</guid>
      <description>Recurrences It describes a sequence of numbers. For instance, an example of a recurrence would be: $T_1 = 1$ $T_n = T_{n-1}+1$ for n &amp;gt;= 2
 They are useful to analyze the performance of recursive algorithms
 Anti-Derivative Method Formula is: $f&#39;(x) = \lim_{h-&amp;gt;0}\frac{f(x)-f(x-h)}{h}$
 In terms of asymptotic analysis, in this case, we only need h to be &amp;ldquo;close&amp;rdquo; to zero but still positive. NOTE: h must be smaller than x.</description>
    </item>
    
    <item>
      <title>CS 477 Study Guide</title>
      <link>https://kaonpositive.github.io/posts/cs477notes02/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs477notes02/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Shortest Path</title>
      <link>https://kaonpositive.github.io/posts/shortestpaths/</link>
      <pubDate>Sat, 21 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/shortestpaths/</guid>
      <description>Djiksta&amp;rsquo;s Algorithm You are given a start vetex $s$, and it finds the shortest path from $s$ to every other vertex in the graph, including your desired destination $t$.
 Shortest Path does not necessarily mean it is the fastest path; it means that the path has the least number of segments (edges).
 Steps for Djikstra&amp;rsquo;s:
 Find the cheapest node starting from the source/start vertex. Update the costs of the neighbors of this node.</description>
    </item>
    
    <item>
      <title>Leetcode Doc</title>
      <link>https://kaonpositive.github.io/posts/leetcode/</link>
      <pubDate>Sun, 10 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/leetcode/</guid>
      <description>notes</description>
    </item>
    
    <item>
      <title>CS 477 Notes 00</title>
      <link>https://kaonpositive.github.io/posts/cs477notes00/</link>
      <pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs477notes00/</guid>
      <description>Types of Running Time:  O(n) - Worst-case Running Time   f(n) = O(g(n)) Grows no faster than n Describes the upper bound It is the maximum number of steps taken in any instance of size n&amp;ndash;calculates the maximum time an algorithm takes to complete execution. Formal Definition of O(n):  f(n) &amp;lt;= c*g(n) for all n &amp;gt;= n0 where n0 can be some number greater than 0 and c is some constant Ex: f(n) = 2n + 3; g(n) = n 2n + 3 &amp;lt;= 10n, which is true    $ \Omega $(n) - Best-case Running Time   f(n) = $ \Omega $(g(n)) Grows at least as fast as n Describes the lower bound Calculates the shortest time an algorithm takes to complete execution Formal Definition of $ \Omega $(n):  f(n) &amp;gt;= c*g(n) for all n &amp;gt;= n0 where n0 can be some number greater than 0 and c is some constant    $ \Theta $(n) - Expected-case Running Time   f(n) = $ \Theta $(g(n)) Means both $ \Omega $(n) and O(n) Gives the average bound (expresses lower and upper bound of algorithm&amp;rsquo;s run time).</description>
    </item>
    
    <item>
      <title>Algorithms</title>
      <link>https://kaonpositive.github.io/posts/algos/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/algos/</guid>
      <description>What is an algorithm?  Sequence of steps that transform input into output.  What is time complexity of an algorithm?  Indicates total time needed by program to run to completion. Expressed by using Big O notation.  What are the types of notation used for time complexity?  Big Oh: Fewer than or same as iterations. Big Omega: More than or same as iterations. Big Theta: Same as iterations.</description>
    </item>
    
    <item>
      <title>OA Notes</title>
      <link>https://kaonpositive.github.io/posts/oanotes/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/oanotes/</guid>
      <description>review data structures and algorithms.
 strings, lists, trees, queues, stacks, graphs, heaps, hash tables, and hash maps. sorts, searches, recursion, iterative approaches, and traversals (BFS and DFS) understand basic programming concepts time yourself as you will have 120 minutes to complete the assessment. practice different types of questions in the Candidate Prep on HackerRank  </description>
    </item>
    
    <item>
      <title>Time Complexity</title>
      <link>https://kaonpositive.github.io/posts/timecomplexity/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/timecomplexity/</guid>
      <description>What is time complexity?   It is the measure of how long an algorithm will run as the size of the input increases&amp;ndash;this examines the proportional time of the largest components of the algorithm.
 Proportional Time: Only being mindful of the running-time of an input of size n, NOT the running-time for a specific input. Example:  int sum{}; for( const auto i : arr ) if( num % 2 == 0 ) sum += num; return sum;  Note: In this example, the loop will iterate the entire array once, so it runs directly proportional to n (linear run time).</description>
    </item>
    
  </channel>
</rss>
