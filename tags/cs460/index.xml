<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cs460 on Jared Rosario</title>
    <link>https://kaonpositive.github.io/tags/cs460/</link>
    <description>Recent content in cs460 on Jared Rosario</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 12 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kaonpositive.github.io/tags/cs460/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Compilers Study Guide -- Midterm</title>
      <link>https://kaonpositive.github.io/posts/compilersmidtermstudyguide/</link>
      <pubDate>Tue, 12 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/compilersmidtermstudyguide/</guid>
      <description>Lexical Analysis (Chapter 3)  Syntax - rules for a syntactically correct program Semantics - meaning of the program.  Lexical Analysis is the process that reads a stream of characters and groups them into tokens based on a set of rules (these rules will create keywords, literals, separators, etc.)
The process for lexical analysis:
 Find all terminals in the grammar Write the scanner  ex:
for( int i = 0; i &amp;lt; 100; ++i )    kind lexeme line column     Token.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 06</title>
      <link>https://kaonpositive.github.io/posts/cs460notes06/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes06/</guid>
      <description>Lecture For CharAt, the type must be a string type.
 PHASE 4 NOTES
 S -&amp;gt; E E -&amp;gt; E + F | F F -&amp;gt; id | (E)
Ex:
   $I_0 = Closure({ [S -&amp;gt; •E] })$     [S-&amp;gt;•E]   [E-&amp;gt;•E+F]   [E-&amp;gt;•F]   [F-&amp;gt;•id]   [F-&amp;gt;•(E)]    E -&amp;gt;
   $I_1 = Goto(I_0, E)$     [S-&amp;gt;E•]   [E-&amp;gt;E•+F]     LOOK AT CANVAS NOTES FOR MORE DETAILS</description>
    </item>
    
    <item>
      <title>CS 460 Notes 05</title>
      <link>https://kaonpositive.github.io/posts/cs460notes05/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes05/</guid>
      <description>Lecture Chapter 4.20 Example: $S -&amp;gt; A B C$ $A -&amp;gt; aA | \epsilon $ $B -&amp;gt; bB | \epsilon $ $C -&amp;gt; cC | \epsilon $
$ w = abbc $
Left-most: $S -&amp;gt; ABC -&amp;gt; aABC -&amp;gt; aBC -&amp;gt; abBC -&amp;gt; abbBC -&amp;gt; abbC -&amp;gt; abbcC -&amp;gt; abbc$
Right-most: $S -&amp;gt; ABC -&amp;gt; ABcC -&amp;gt; ABC -&amp;gt; AbBc -&amp;gt; AbbBc -&amp;gt; Abbc -&amp;gt; aAbbc -&amp;gt; abbc$
 NOTE: FOR RIGHT-MOST DERIVATIONS, MUST REFER TO HOW IT WAS DERIVED ON THE LEFT-MOST.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 04</title>
      <link>https://kaonpositive.github.io/posts/cs460notes04/</link>
      <pubDate>Wed, 14 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes04/</guid>
      <description>Lecture Notes Chapter 6 Name Resolution and Scoping:
Reading Chapter 6: Name Resolution and Scoping List of what can be named in a program:
 Variables (local/global) and parameters Procedures/Functions/Methods/Sub-routines Modules/Packages Classes Fields Program locations (labels) Types and Structures  Activation Records All code runs in a data context (a state)&amp;ndash;the context is the data associated w/ the running code. The data associated is typically the state of parameters and the local variables; the state associated w/ an object is kept in dynamically allocated blocks of memory on the heap.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 03</title>
      <link>https://kaonpositive.github.io/posts/cs460notes03/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes03/</guid>
      <description>Lecture Notes Reading Chapter 5 Parse Trees Parse Trees ( sometimes referred to as Abstract Syntax Trees (AST) ) are used as an internal representation of a sourced program (recall that the parser generates a parse-tree representation of the correctly parsed program).
A parse tree preserves rules for associativity, commutativity, and precedence as defined by the grammar.
A parse tree consists of two different kinds of nodes:
 Internal Nodes - correspond to nonterminals from the grammar Leaf Nodes - correspond to the terminals of the grammar as found in the parsed source program.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 02</title>
      <link>https://kaonpositive.github.io/posts/cs460notes02/</link>
      <pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes02/</guid>
      <description>Lecture Notes RECALL: A Parser&amp;rsquo;s job is to make sure if the program is syntactically correct.
Types of Parsers:
 LL(k) - First L says to scan from Left to Right; Second L says to use left-most derivation (always develop the left-most non-terminal in a sentential form).   NOTE: A good thing about a LL(k) parser is that it is linear&amp;ndash;there is no backtracking.
 LR(k) - First L says to scan from Left to Right; Second R says to use reverse right-most derivation (start w/ input string, find appropriate grammar rule, then start at the right).</description>
    </item>
    
    <item>
      <title>CS 460 Notes 01</title>
      <link>https://kaonpositive.github.io/posts/cs460notes01/</link>
      <pubDate>Wed, 24 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes01/</guid>
      <description>Lecture Notes 1/22 Rules for a Regular Expression:
if s &amp;amp; t are regular expressions, then:
 s | t s * t (concatenate) s*  ( continued from last lecture ) NFA for recognizing tokens construct NFAs for each construct of a Regular Expression.
If all tokens of a language are represented by regular expressions $r_1, r_2, r_3, &amp;hellip; r_n$, then we can create $N(r_1), N(r_2), &amp;hellip; N(r_n)$.
NFA is classified somewhat as a greedy algorithm.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 00</title>
      <link>https://kaonpositive.github.io/posts/cs460notes00/</link>
      <pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes00/</guid>
      <description>Lecture Notes 1/22 Chapter 1 Syntax - rules for what a syntactically program looks like ( the structure of the language is correct )
Semantics - meaning of the program
In terms of a compiler, the compiler would output the target code. That target code.
Frontend - syntax checking, semantic checking
Backend - create target program (code generation) and optimization
Frontend -&amp;gt; i (intermediate code or parse tree) -&amp;gt; Backend</description>
    </item>
    
  </channel>
</rss>
