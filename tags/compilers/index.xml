<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>compilers on Jared Rosario</title>
    <link>https://kaonpositive.github.io/tags/compilers/</link>
    <description>Recent content in compilers on Jared Rosario</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 14 Feb 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://kaonpositive.github.io/tags/compilers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS 460 Notes 04</title>
      <link>https://kaonpositive.github.io/posts/cs460notes04/</link>
      <pubDate>Wed, 14 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes04/</guid>
      <description>Lecture Notes Chapter 6 Name Resolution and Scoping:
Reading Chapter 6: Name Resolution and Scoping List of what can be named in a program:
 Variables (local/global) and parameters Procedures/Functions/Methods/Sub-routines Modules/Packages Classes Fields Program locations (labels) Types and Structures  Activation Records All code runs in a data context (a state)&amp;ndash;the context is the data associated w/ the running code. The data associated is typically the state of parameters and the local variables; the state associated w/ an object is kept in dynamically allocated blocks of memory on the heap.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 03</title>
      <link>https://kaonpositive.github.io/posts/cs460notes03/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes03/</guid>
      <description>Lecture Notes Reading Chapter 5 Parse Trees Parse Trees ( sometimes referred to as Abstract Syntax Trees (AST) ) are used as an internal representation of a sourced program (recall that the parser generates a parse-tree representation of the correctly parsed program).
A parse tree preserves rules for associativity, commutativity, and precedence as defined by the grammar.
A parse tree consists of two different kinds of nodes:
 Internal Nodes - correspond to nonterminals from the grammar Leaf Nodes - correspond to the terminals of the grammar as found in the parsed source program.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 02</title>
      <link>https://kaonpositive.github.io/posts/cs460notes02/</link>
      <pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes02/</guid>
      <description>Lecture Notes RECALL: A Parser&amp;rsquo;s job is to make sure if the program is syntactically correct.
Types of Parsers:
 LL(k) - First L says to scan from Left to Right; Second L says to use left-most derivation (always develop the left-most non-terminal in a sentential form).   NOTE: A good thing about a LL(k) parser is that it is linear&amp;ndash;there is no backtracking.
 LR(k) - First L says to scan from Left to Right; Second R says to use reverse right-most derivation (start w/ input string, find appropriate grammar rule, then start at the right).</description>
    </item>
    
    <item>
      <title>CS 460 Notes 01</title>
      <link>https://kaonpositive.github.io/posts/cs460notes01/</link>
      <pubDate>Wed, 24 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes01/</guid>
      <description>Lecture Notes 1/22 Rules for a Regular Expression:
if s &amp;amp; t are regular expressions, then:
 s | t s * t (concatenate) s*  ( continued from last lecture ) NFA for recognizing tokens construct NFAs for each construct of a Regular Expression.
If all tokens of a language are represented by regular expressions $r_1, r_2, r_3, &amp;hellip; r_n$, then we can create $N(r_1), N(r_2), &amp;hellip; N(r_n)$.
NFA is classified somewhat as a greedy algorithm.</description>
    </item>
    
    <item>
      <title>CS 460 Notes 00</title>
      <link>https://kaonpositive.github.io/posts/cs460notes00/</link>
      <pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/cs460notes00/</guid>
      <description>Lecture Notes 1/22 Chapter 1 Syntax - rules for what a syntactically program looks like ( the structure of the language is correct )
Semantics - meaning of the program
In terms of a compiler, the compiler would output the target code. That target code.
Frontend - syntax checking, semantic checking
Backend - create target program (code generation) and optimization
Frontend -&amp;gt; i (intermediate code or parse tree) -&amp;gt; Backend</description>
    </item>
    
  </channel>
</rss>
