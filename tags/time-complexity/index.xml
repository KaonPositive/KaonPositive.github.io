<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>time complexity on Jared Rosario</title>
    <link>https://kaonpositive.github.io/tags/time-complexity/</link>
    <description>Recent content in time complexity on Jared Rosario</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 25 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://kaonpositive.github.io/tags/time-complexity/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Time Complexity</title>
      <link>https://kaonpositive.github.io/posts/timecomplexity/</link>
      <pubDate>Fri, 25 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://kaonpositive.github.io/posts/timecomplexity/</guid>
      <description>What is time complexity?   It is the measure of how long an algorithm will run as the size of the input increases&amp;ndash;this examines the proportional time of the largest components of the algorithm.
 Proportional Time: Only being mindful of the running-time of an input of size n, NOT the running-time for a specific input. Example:  int sum{}; for( const auto i : arr ) if( num % 2 == 0 ) sum += num; return sum;  Note: In this example, the loop will iterate the entire array once, so it runs directly proportional to n (linear run time).</description>
    </item>
    
  </channel>
</rss>
